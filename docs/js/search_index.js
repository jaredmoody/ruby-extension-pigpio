var search_data = {"index":{"searchIndex":["pigpio","bank","bscxfer","callback","callbackerror","constant","gpio","if","pwm","pulse","usergpio","bank()","bb_i2c_close()","bb_i2c_open()","bb_i2c_zip()","bb_serial_invert()","bb_serial_read()","bb_serial_read_close()","bb_serial_read_open()","bb_spi_close()","bb_spi_open()","bb_spi_xfer()","bsc_i2c()","bsc_xfer()","callback()","callback()","callback_cancel()","cancel()","clear()","clear_bank_1()","clear_bank_2()","connect()","control=()","current_tick()","delete_script()","dutycycle()","dutycycle=()","event_callback()","event_callback_cancel()","event_trigger()","frequency()","frequency=()","get_pwm_dutycycle()","get_pwm_frequency()","get_pwm_range()","get_pwm_real_range()","get_current_tick()","get_hardware_revision()","get_mode()","get_pad_strength()","get_pigpio_version()","get_servo_pulsewidth()","glitch_filter()","gpio()","gpio()","gpio_read()","gpio_trigger()","gpio_write()","hardware_pwm()","hardware_pwm()","hardware_clock()","hardware_clock()","hardware_revision()","i2c_block_process_call()","i2c_close()","i2c_open()","i2c_process_call()","i2c_read_block_data()","i2c_read_byte()","i2c_read_byte_data()","i2c_read_device()","i2c_read_i2c_block_data()","i2c_read_word_data()","i2c_write_block_data()","i2c_write_byte()","i2c_write_byte_data()","i2c_write_device()","i2c_write_i2c_block_data()","i2c_write_quick()","i2c_write_word_data()","i2c_zip()","id()","make()","make()","mode()","mode=()","new()","new()","new()","new()","noise_filter()","notify_begin()","notify_close()","notify_open()","notify_pause()","pi()","pigpio_error()","pigpio_start()","pigpio_stop()","pigpio_version()","pigpiod_if_version()","pud()","pwm()","range()","range=()","read()","read()","read_bank_1()","read_bank_2()","real_range()","run_script()","rxbuf()","script_status()","serial_close()","serial_data_available()","serial_open()","serial_read()","serial_read_byte()","serial_write()","serial_write_byte()","servo_pulsewidth()","servo_pulsewidth=()","set()","set_pwm_dutycycle()","set_pwm_frequency()","set_pwm_range()","set_bank_1()","set_bank_2()","set_glitch_filter()","set_mode()","set_noise_filter()","set_pad_strength()","set_pull_up_down()","set_servo_pulsewidth()","set_watchdog()","spi_close()","spi_open()","spi_read()","spi_write()","spi_xfer()","stop()","stop_script()","store_script()","time_time()","trigger()","txbuf=()","wait_for_edge()","wait_for_edge()","wait_for_event()","watchdog()","wave_add_generic()","wave_add_new()","wave_add_serial()","wave_chain()","wave_clear()","wave_create()","wave_delete()","wave_get_cbs()","wave_get_high_cbs()","wave_get_high_micros()","wave_get_high_pulses()","wave_get_max_cbs()","wave_get_max_micros()","wave_get_max_pulses()","wave_get_micros()","wave_get_pulses()","wave_send_once()","wave_send_repeat()","wave_send_using_mode()","wave_tx_at()","wave_tx_busy()","wave_tx_stop()","write()"],"longSearchIndex":["pigpio","pigpio::bank","pigpio::bscxfer","pigpio::callback","pigpio::callbackerror","pigpio::constant","pigpio::gpio","pigpio::if","pigpio::pwm","pigpio::pulse","pigpio::usergpio","pigpio#bank()","pigpio::if::bb_i2c_close()","pigpio::if::bb_i2c_open()","pigpio::if::bb_i2c_zip()","pigpio::if::bb_serial_invert()","pigpio::if::bb_serial_read()","pigpio::if::bb_serial_read_close()","pigpio::if::bb_serial_read_open()","pigpio::if::bb_spi_close()","pigpio::if::bb_spi_open()","pigpio::if::bb_spi_xfer()","pigpio::if::bsc_i2c()","pigpio::if::bsc_xfer()","pigpio::if::callback()","pigpio::usergpio#callback()","pigpio::if::callback_cancel()","pigpio::callback#cancel()","pigpio::bank#clear()","pigpio::if::clear_bank_1()","pigpio::if::clear_bank_2()","pigpio#connect()","pigpio::bscxfer#control=()","pigpio#current_tick()","pigpio::if::delete_script()","pigpio::pwm#dutycycle()","pigpio::pwm#dutycycle=()","pigpio::if::event_callback()","pigpio::if::event_callback_cancel()","pigpio::if::event_trigger()","pigpio::pwm#frequency()","pigpio::pwm#frequency=()","pigpio::if::get_pwm_dutycycle()","pigpio::if::get_pwm_frequency()","pigpio::if::get_pwm_range()","pigpio::if::get_pwm_real_range()","pigpio::if::get_current_tick()","pigpio::if::get_hardware_revision()","pigpio::if::get_mode()","pigpio::if::get_pad_strength()","pigpio::if::get_pigpio_version()","pigpio::if::get_servo_pulsewidth()","pigpio::usergpio#glitch_filter()","pigpio#gpio()","pigpio::gpio#gpio()","pigpio::if::gpio_read()","pigpio::if::gpio_trigger()","pigpio::if::gpio_write()","pigpio::gpio#hardware_pwm()","pigpio::if::hardware_pwm()","pigpio::gpio#hardware_clock()","pigpio::if::hardware_clock()","pigpio#hardware_revision()","pigpio::if::i2c_block_process_call()","pigpio::if::i2c_close()","pigpio::if::i2c_open()","pigpio::if::i2c_process_call()","pigpio::if::i2c_read_block_data()","pigpio::if::i2c_read_byte()","pigpio::if::i2c_read_byte_data()","pigpio::if::i2c_read_device()","pigpio::if::i2c_read_i2c_block_data()","pigpio::if::i2c_read_word_data()","pigpio::if::i2c_write_block_data()","pigpio::if::i2c_write_byte()","pigpio::if::i2c_write_byte_data()","pigpio::if::i2c_write_device()","pigpio::if::i2c_write_i2c_block_data()","pigpio::if::i2c_write_quick()","pigpio::if::i2c_write_word_data()","pigpio::if::i2c_zip()","pigpio::callback#id()","pigpio::bscxfer::make()","pigpio::pulse::make()","pigpio::gpio#mode()","pigpio::gpio#mode=()","pigpio::new()","pigpio::bank::new()","pigpio::gpio::new()","pigpio::pwm::new()","pigpio::usergpio#noise_filter()","pigpio::if::notify_begin()","pigpio::if::notify_close()","pigpio::if::notify_open()","pigpio::if::notify_pause()","pigpio#pi()","pigpio::if::pigpio_error()","pigpio::if::pigpio_start()","pigpio::if::pigpio_stop()","pigpio#pigpio_version()","pigpio::if::pigpiod_if_version()","pigpio::gpio#pud()","pigpio::usergpio#pwm()","pigpio::pwm#range()","pigpio::pwm#range=()","pigpio::bank#read()","pigpio::gpio#read()","pigpio::if::read_bank_1()","pigpio::if::read_bank_2()","pigpio::pwm#real_range()","pigpio::if::run_script()","pigpio::bscxfer#rxbuf()","pigpio::if::script_status()","pigpio::if::serial_close()","pigpio::if::serial_data_available()","pigpio::if::serial_open()","pigpio::if::serial_read()","pigpio::if::serial_read_byte()","pigpio::if::serial_write()","pigpio::if::serial_write_byte()","pigpio::pwm#servo_pulsewidth()","pigpio::pwm#servo_pulsewidth=()","pigpio::bank#set()","pigpio::if::set_pwm_dutycycle()","pigpio::if::set_pwm_frequency()","pigpio::if::set_pwm_range()","pigpio::if::set_bank_1()","pigpio::if::set_bank_2()","pigpio::if::set_glitch_filter()","pigpio::if::set_mode()","pigpio::if::set_noise_filter()","pigpio::if::set_pad_strength()","pigpio::if::set_pull_up_down()","pigpio::if::set_servo_pulsewidth()","pigpio::if::set_watchdog()","pigpio::if::spi_close()","pigpio::if::spi_open()","pigpio::if::spi_read()","pigpio::if::spi_write()","pigpio::if::spi_xfer()","pigpio#stop()","pigpio::if::stop_script()","pigpio::if::store_script()","pigpio::if::time_time()","pigpio::usergpio#trigger()","pigpio::bscxfer#txbuf=()","pigpio::if::wait_for_edge()","pigpio::usergpio#wait_for_edge()","pigpio::if::wait_for_event()","pigpio::usergpio#watchdog()","pigpio::if::wave_add_generic()","pigpio::if::wave_add_new()","pigpio::if::wave_add_serial()","pigpio::if::wave_chain()","pigpio::if::wave_clear()","pigpio::if::wave_create()","pigpio::if::wave_delete()","pigpio::if::wave_get_cbs()","pigpio::if::wave_get_high_cbs()","pigpio::if::wave_get_high_micros()","pigpio::if::wave_get_high_pulses()","pigpio::if::wave_get_max_cbs()","pigpio::if::wave_get_max_micros()","pigpio::if::wave_get_max_pulses()","pigpio::if::wave_get_micros()","pigpio::if::wave_get_pulses()","pigpio::if::wave_send_once()","pigpio::if::wave_send_repeat()","pigpio::if::wave_send_using_mode()","pigpio::if::wave_tx_at()","pigpio::if::wave_tx_busy()","pigpio::if::wave_tx_stop()","pigpio::gpio#write()"],"info":[["Pigpio","","Pigpio.html","","<p>This class has some constances for pigpio library.\n"],["Pigpio::Bank","","Pigpio/Bank.html","",""],["Pigpio::BscXfer","","Pigpio/BscXfer.html","","<p>This class wrap bsc_xfer_t.\n"],["Pigpio::Callback","","Pigpio/Callback.html","","<p>The class for callback.\n"],["Pigpio::CallbackError","","Pigpio/CallbackError.html","","<p>The class for callback error.\n"],["Pigpio::Constant","","Pigpio/Constant.html","",""],["Pigpio::GPIO","","Pigpio/GPIO.html","",""],["Pigpio::IF","","Pigpio/IF.html","","<p>This module is a ruby binding to pigpio library.\n"],["Pigpio::PWM","","Pigpio/PWM.html","",""],["Pigpio::Pulse","","Pigpio/Pulse.html","","<p>This class wrap gpioPulse_t.\n"],["Pigpio::UserGPIO","","Pigpio/UserGPIO.html","",""],["bank","Pigpio","Pigpio.html#method-i-bank","(num)",""],["bb_i2c_close","Pigpio::IF","Pigpio/IF.html#method-c-bb_i2c_close","(p1, p2)","<p>This function stops bit banging I2C on a pair of GPIO previously opened\nwith [<strong>bb_i2c_open</strong>].\n<p>. .\n\n<pre> pi: &gt;=0 ...</pre>\n"],["bb_i2c_open","Pigpio::IF","Pigpio/IF.html#method-c-bb_i2c_open","(p1, p2, p3, p4)","<p>This function selects a pair of GPIO for bit banging I2C at a specified\nbaud rate.\n<p>Bit banging I2C allows …\n"],["bb_i2c_zip","Pigpio::IF","Pigpio/IF.html#method-c-bb_i2c_zip","(p1, p2, p3, p4)","<p>This function executes a sequence of bit banged I2C operations.  The\noperations to be performed are specified …\n"],["bb_serial_invert","Pigpio::IF","Pigpio/IF.html#method-c-bb_serial_invert","(p1, p2, p3)","<p>This function inverts serial logic for big bang serial reads.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["bb_serial_read","Pigpio::IF","Pigpio/IF.html#method-c-bb_serial_read","(p1, p2, p3)","<p>This function copies up to bufSize bytes of data read from the bit bang\nserial cyclic buffer to the buffer …\n"],["bb_serial_read_close","Pigpio::IF","Pigpio/IF.html#method-c-bb_serial_read_close","(p1, p2)","<p>This function closes a GPIO for bit bang reading of serial data.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["bb_serial_read_open","Pigpio::IF","Pigpio/IF.html#method-c-bb_serial_read_open","(p1, p2, p3, p4)","<p>This function opens a GPIO for bit bang reading of serial data.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["bb_spi_close","Pigpio::IF","Pigpio/IF.html#method-c-bb_spi_close","(p1, p2)","<p>This function stops bit banging SPI on a set of GPIO opened with\n[<strong>bbSPIOpen</strong>].\n<p>. .\n\n<pre>pi: &gt;=0 (as returned ...</pre>\n"],["bb_spi_open","Pigpio::IF","Pigpio/IF.html#method-c-bb_spi_open","(p1, p2, p3, p4, p5, p6, p7)","<p>This function selects a set of GPIO for bit banging SPI at a specified baud\nrate.\n<p>. .\n\n<pre>       pi: &gt;=0 (as ...</pre>\n"],["bb_spi_xfer","Pigpio::IF","Pigpio/IF.html#method-c-bb_spi_xfer","(p1, p2, p3)","<p>This function executes a bit banged SPI transfer.\n<p>. .\n\n<pre>   pi: &gt;=0 (as returned by [*pigpio_start*]).\n   ...</pre>\n"],["bsc_i2c","Pigpio::IF","Pigpio/IF.html#method-c-bsc_i2c","(p1, p2, p3)","<p>This function allows the Pi to act as a slave I2C device.\n<p>The data bytes (if any) are written to the  …\n"],["bsc_xfer","Pigpio::IF","Pigpio/IF.html#method-c-bsc_xfer","(p1, p2)","<p>This function provides a low-level interface to the SPI/I2C Slave\nperipheral.  This peripheral allows …\n"],["callback","Pigpio::IF","Pigpio/IF.html#method-c-callback","(*args)","<p>This function initialises a new callback.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]).\nuser_gpio: ...</pre>\n"],["callback","Pigpio::UserGPIO","Pigpio/UserGPIO.html#method-i-callback","(edge,&blk)",""],["callback_cancel","Pigpio::IF","Pigpio/IF.html#method-c-callback_cancel","(p1)","<p>This function cancels a callback identified by its id.\n<p>. .\n\n<pre>callback_id: &gt;=0, as returned by a call to [*callback*] ...</pre>\n"],["cancel","Pigpio::Callback","Pigpio/Callback.html#method-i-cancel","()","<p>This function cancels a callback/event-callback.\n<p>The function returns 0 if OK, otherwise pigif_callback_not_found. …\n"],["clear","Pigpio::Bank","Pigpio/Bank.html#method-i-clear","(bits)",""],["clear_bank_1","Pigpio::IF","Pigpio/IF.html#method-c-clear_bank_1","(p1, p2)","<p>Clears GPIO 0-31 if the corresponding bit in bits is set.\n<p>. .\n\n<pre>  pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["clear_bank_2","Pigpio::IF","Pigpio/IF.html#method-c-clear_bank_2","(p1, p2)","<p>Clears GPIO 32-53 if the corresponding bit (0-21) in bits is set.\n<p>. .\n\n<pre>  pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["connect","Pigpio","Pigpio.html#method-i-connect","()",""],["control=","Pigpio::BscXfer","Pigpio/BscXfer.html#method-i-control-3D","(p1)","<p>Setter\n"],["current_tick","Pigpio","Pigpio.html#method-i-current_tick","()",""],["delete_script","Pigpio::IF","Pigpio/IF.html#method-c-delete_script","(p1, p2)","<p>This function deletes a stored script.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]).\nscript_id: ...</pre>\n"],["dutycycle","Pigpio::PWM","Pigpio/PWM.html#method-i-dutycycle","()",""],["dutycycle=","Pigpio::PWM","Pigpio/PWM.html#method-i-dutycycle-3D","(dutycycle)",""],["event_callback","Pigpio::IF","Pigpio/IF.html#method-c-event_callback","(*args)","<p>This function initialises an event callback.\n<p>. .\n\n<pre>   pi: &gt;=0 (as returned by [*pigpio_start*]).\nevent: 0-31.</pre>\n"],["event_callback_cancel","Pigpio::IF","Pigpio/IF.html#method-c-event_callback_cancel","(p1)","<p>This function cancels an event callback identified by its id.\n<p>. .\n\n<pre>callback_id: &gt;=0, as returned by a call ...</pre>\n"],["event_trigger","Pigpio::IF","Pigpio/IF.html#method-c-event_trigger","(p1, p2)","<p>This function signals the occurrence of an event.\n<p>. .\n\n<pre>   pi: &gt;=0 (as returned by [*pigpio_start*]).\nevent: ...</pre>\n"],["frequency","Pigpio::PWM","Pigpio/PWM.html#method-i-frequency","()",""],["frequency=","Pigpio::PWM","Pigpio/PWM.html#method-i-frequency-3D","(frequency)",""],["get_PWM_dutycycle","Pigpio::IF","Pigpio/IF.html#method-c-get_PWM_dutycycle","(p1, p2)","<p>Return the PWM dutycycle in use on a GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]).\nuser_gpio: ...</pre>\n"],["get_PWM_frequency","Pigpio::IF","Pigpio/IF.html#method-c-get_PWM_frequency","(p1, p2)","<p>Get the frequency of PWM being used on the GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["get_PWM_range","Pigpio::IF","Pigpio/IF.html#method-c-get_PWM_range","(p1, p2)","<p>Get the range of PWM values being used on the GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["get_PWM_real_range","Pigpio::IF","Pigpio/IF.html#method-c-get_PWM_real_range","(p1, p2)","<p>Get the real underlying range of PWM values being used on the GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by ...</pre>\n"],["get_current_tick","Pigpio::IF","Pigpio/IF.html#method-c-get_current_tick","(p1)","<p>Gets the current system tick.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["get_hardware_revision","Pigpio::IF","Pigpio/IF.html#method-c-get_hardware_revision","(p1)","<p>Get the Pi&#39;s hardware revision number.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["get_mode","Pigpio::IF","Pigpio/IF.html#method-c-get_mode","(p1, p2)","<p>Get the GPIO mode.\n<p>. .\n\n<pre>  pi: &gt;=0 (as returned by [*pigpio_start*]).\ngpio: 0-53.</pre>\n"],["get_pad_strength","Pigpio::IF","Pigpio/IF.html#method-c-get_pad_strength","(p1, p2)","<p>This function returns the pad drive strength in mA.\n<p>. .\n\n<pre> pi: &gt;=0 (as returned by [*pigpio_start*]).\npad: ...</pre>\n"],["get_pigpio_version","Pigpio::IF","Pigpio/IF.html#method-c-get_pigpio_version","(p1)","<p>Returns the pigpio version.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["get_servo_pulsewidth","Pigpio::IF","Pigpio/IF.html#method-c-get_servo_pulsewidth","(p1, p2)","<p>Return the servo pulsewidth in use on a GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]).\nuser_gpio: ...</pre>\n"],["glitch_filter","Pigpio::UserGPIO","Pigpio/UserGPIO.html#method-i-glitch_filter","(steady)",""],["gpio","Pigpio","Pigpio.html#method-i-gpio","(gpio)",""],["gpio","Pigpio::GPIO","Pigpio/GPIO.html#method-i-gpio","()",""],["gpio_read","Pigpio::IF","Pigpio/IF.html#method-c-gpio_read","(p1, p2)","<p>Read the GPIO level.\n<p>. .\n\n<pre>  pi: &gt;=0 (as returned by [*pigpio_start*]).\ngpio:0-53.</pre>\n"],["gpio_trigger","Pigpio::IF","Pigpio/IF.html#method-c-gpio_trigger","(p1, p2, p3, p4)","<p>This function sends a trigger pulse to a GPIO.  The GPIO is set to level\nfor pulseLen microseconds and …\n"],["gpio_write","Pigpio::IF","Pigpio/IF.html#method-c-gpio_write","(p1, p2, p3)","<p>Write the GPIO level.\n<p>. .\n\n<pre>   pi: &gt;=0 (as returned by [*pigpio_start*]).\n gpio: 0-53.\nlevel: 0, 1.</pre>\n"],["hardware_PWM","Pigpio::GPIO","Pigpio/GPIO.html#method-i-hardware_PWM","(vPWMfreq,vPWMduty)",""],["hardware_PWM","Pigpio::IF","Pigpio/IF.html#method-c-hardware_PWM","(p1, p2, p3, p4)","<p>Starts hardware PWM on a GPIO at the specified frequency and dutycycle.\nFrequencies above 30MHz are unlikely …\n"],["hardware_clock","Pigpio::GPIO","Pigpio/GPIO.html#method-i-hardware_clock","(clkfreq)",""],["hardware_clock","Pigpio::IF","Pigpio/IF.html#method-c-hardware_clock","(p1, p2, p3)","<p>Starts a hardware clock on a GPIO at the specified frequency. Frequencies\nabove 30MHz are unlikely to …\n"],["hardware_revision","Pigpio","Pigpio.html#method-i-hardware_revision","()",""],["i2c_block_process_call","Pigpio::IF","Pigpio/IF.html#method-c-i2c_block_process_call","(p1, p2, p3, p4)","<p>This writes data bytes to the specified register of the device associated\nwith handle and reads a device …\n"],["i2c_close","Pigpio::IF","Pigpio/IF.html#method-c-i2c_close","(p1, p2)","<p>This closes the I2C device associated with the handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["i2c_open","Pigpio::IF","Pigpio/IF.html#method-c-i2c_open","(p1, p2, p3, p4)","<p>This returns a handle for the device at address i2c_addr on bus i2c_bus.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned ...</pre>\n"],["i2c_process_call","Pigpio::IF","Pigpio/IF.html#method-c-i2c_process_call","(p1, p2, p3, p4)","<p>This writes 16 bits of data to the specified register of the device\nassociated with handle and and reads …\n"],["i2c_read_block_data","Pigpio::IF","Pigpio/IF.html#method-c-i2c_read_block_data","(p1, p2, p3)","<p>This reads a block of up to 32 bytes from the specified register of the\ndevice associated with handle. …\n"],["i2c_read_byte","Pigpio::IF","Pigpio/IF.html#method-c-i2c_read_byte","(p1, p2)","<p>This reads a single byte from the device associated with handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["i2c_read_byte_data","Pigpio::IF","Pigpio/IF.html#method-c-i2c_read_byte_data","(p1, p2, p3)","<p>This reads a single byte from the specified register of the device\nassociated with handle.\n<p>. .\n\n<pre>     pi: ...</pre>\n"],["i2c_read_device","Pigpio::IF","Pigpio/IF.html#method-c-i2c_read_device","(p1, p2, p3)","<p>This reads count bytes from the raw device into buf.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["i2c_read_i2c_block_data","Pigpio::IF","Pigpio/IF.html#method-c-i2c_read_i2c_block_data","(p1, p2, p3, p4)","<p>This reads count bytes from the specified register of the device associated\nwith handle .  The count …\n"],["i2c_read_word_data","Pigpio::IF","Pigpio/IF.html#method-c-i2c_read_word_data","(p1, p2, p3)","<p>This reads a single 16 bit word from the specified register of the device\nassociated with handle.\n<p>. . …\n"],["i2c_write_block_data","Pigpio::IF","Pigpio/IF.html#method-c-i2c_write_block_data","(p1, p2, p3, p4)","<p>This writes up to 32 bytes to the specified register of the device\nassociated with handle.\n<p>. .\n\n<pre>     pi: ...</pre>\n"],["i2c_write_byte","Pigpio::IF","Pigpio/IF.html#method-c-i2c_write_byte","(p1, p2, p3)","<p>This sends a single byte to the device associated with handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["i2c_write_byte_data","Pigpio::IF","Pigpio/IF.html#method-c-i2c_write_byte_data","(p1, p2, p3, p4)","<p>This writes a single byte to the specified register of the device\nassociated with handle.\n<p>. .\n\n<pre>     pi: ...</pre>\n"],["i2c_write_device","Pigpio::IF","Pigpio/IF.html#method-c-i2c_write_device","(p1, p2, p3)","<p>This writes count bytes from buf to the raw device.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["i2c_write_i2c_block_data","Pigpio::IF","Pigpio/IF.html#method-c-i2c_write_i2c_block_data","(p1, p2, p3, p4)","<p>This writes 1 to 32 bytes to the specified register of the device\nassociated with handle.\n<p>. .\n\n<pre>     pi: ...</pre>\n"],["i2c_write_quick","Pigpio::IF","Pigpio/IF.html#method-c-i2c_write_quick","(p1, p2, p3)","<p>This sends a single bit (in the Rd/Wr bit) to the device associated with\nhandle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned ...</pre>\n"],["i2c_write_word_data","Pigpio::IF","Pigpio/IF.html#method-c-i2c_write_word_data","(p1, p2, p3, p4)","<p>This writes a single 16 bit word to the specified register of the device\nassociated with handle.\n<p>. .\n\n<pre>  ...</pre>\n"],["i2c_zip","Pigpio::IF","Pigpio/IF.html#method-c-i2c_zip","(p1, p2, p3, p4)","<p>This function executes a sequence of I2C operations.  The operations to be\nperformed are specified by …\n"],["id","Pigpio::Callback","Pigpio/Callback.html#method-i-id","()","<p>get callback id.return Integer.\n"],["make","Pigpio::BscXfer","Pigpio/BscXfer.html#method-c-make","()","<p>Constructor of bsc_xfer_t as Pigpio::BscXfer class\n\n<pre>typedef struct\n{\n  uint32_t control;          // Write ...</pre>\n"],["make","Pigpio::Pulse","Pigpio/Pulse.html#method-c-make","(p1, p2, p3)","<p>Constructor of gpioPulse_t as Pigpio::Pulse class . .\n\n<pre>typedef struct\n{\n   uint32_t gpioOn;\n   uint32_t ...</pre>\n"],["mode","Pigpio::GPIO","Pigpio/GPIO.html#method-i-mode","()",""],["mode=","Pigpio::GPIO","Pigpio/GPIO.html#method-i-mode-3D","(mode)",""],["new","Pigpio","Pigpio.html#method-c-new","(addr=nil,port=nil,&blk)",""],["new","Pigpio::Bank","Pigpio/Bank.html#method-c-new","(pi,num)",""],["new","Pigpio::GPIO","Pigpio/GPIO.html#method-c-new","(pi,gpio)",""],["new","Pigpio::PWM","Pigpio/PWM.html#method-c-new","(pi,gpio)",""],["noise_filter","Pigpio::UserGPIO","Pigpio/UserGPIO.html#method-i-noise_filter","(steady,active)",""],["notify_begin","Pigpio::IF","Pigpio/IF.html#method-c-notify_begin","(p1, p2, p3)","<p>Start notifications on a previously opened handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]).\nhandle: ...</pre>\n"],["notify_close","Pigpio::IF","Pigpio/IF.html#method-c-notify_close","(p1, p2)","<p>Stop notifications on a previously opened handle and release the handle for\nreuse.\n<p>. .\n\n<pre>    pi: &gt;=0 (as ...</pre>\n"],["notify_open","Pigpio::IF","Pigpio/IF.html#method-c-notify_open","(p1)","<p>Get a free notification handle.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["notify_pause","Pigpio::IF","Pigpio/IF.html#method-c-notify_pause","(p1, p2)","<p>Pause notifications on a previously opened handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]).\nhandle: ...</pre>\n"],["pi","Pigpio","Pigpio.html#method-i-pi","()",""],["pigpio_error","Pigpio::IF","Pigpio/IF.html#method-c-pigpio_error","(p1)","<p>Return a text description for an error code.\n<p>. .\n\n<pre>errnum: the error code.</pre>\n"],["pigpio_start","Pigpio::IF","Pigpio/IF.html#method-c-pigpio_start","(*args)","<p>Connect to the pigpio daemon.  Reserving command and notification streams.\n<p>. .\n\n<pre>addrStr: specifies the host ...</pre>\n"],["pigpio_stop","Pigpio::IF","Pigpio/IF.html#method-c-pigpio_stop","(p1)","<p>Terminates the connection to a pigpio daemon and releases resources used by\nthe library.\n<p>. .\n\n<pre>pi: &gt;=0 (as ...</pre>\n"],["pigpio_version","Pigpio","Pigpio.html#method-i-pigpio_version","()",""],["pigpiod_if_version","Pigpio::IF","Pigpio/IF.html#method-c-pigpiod_if_version","()","<p>Return the pigpiod_if2 version.\n<p>See also: pigpio site\n"],["pud","Pigpio::GPIO","Pigpio/GPIO.html#method-i-pud","(pud)",""],["pwm","Pigpio::UserGPIO","Pigpio/UserGPIO.html#method-i-pwm","()",""],["range","Pigpio::PWM","Pigpio/PWM.html#method-i-range","()",""],["range=","Pigpio::PWM","Pigpio/PWM.html#method-i-range-3D","(range)",""],["read","Pigpio::Bank","Pigpio/Bank.html#method-i-read","()",""],["read","Pigpio::GPIO","Pigpio/GPIO.html#method-i-read","()",""],["read_bank_1","Pigpio::IF","Pigpio/IF.html#method-c-read_bank_1","(p1)","<p>Read the levels of the bank 1 GPIO (GPIO 0-31).\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["read_bank_2","Pigpio::IF","Pigpio/IF.html#method-c-read_bank_2","(p1)","<p>Read the levels of the bank 2 GPIO (GPIO 32-53).\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["real_range","Pigpio::PWM","Pigpio/PWM.html#method-i-real_range","()",""],["run_script","Pigpio::IF","Pigpio/IF.html#method-c-run_script","(p1, p2, p3)","<p>This function runs a stored script.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]).\nscript_id: &gt;=0, ...</pre>\n"],["rxBuf","Pigpio::BscXfer","Pigpio/BscXfer.html#method-i-rxBuf","()","<p>Getter\n"],["script_status","Pigpio::IF","Pigpio/IF.html#method-c-script_status","(p1, p2)","<p>This function returns the run status of a stored script as well as the\ncurrent values of parameters 0 …\n"],["serial_close","Pigpio::IF","Pigpio/IF.html#method-c-serial_close","(p1, p2)","<p>This function closes the serial device associated with handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["serial_data_available","Pigpio::IF","Pigpio/IF.html#method-c-serial_data_available","(p1, p2)","<p>Returns the number of bytes available to be read from the device associated\nwith handle.\n<p>. .\n\n<pre>    pi: &gt;=0 ...</pre>\n"],["serial_open","Pigpio::IF","Pigpio/IF.html#method-c-serial_open","(p1, p2, p3, p4)","<p>This function opens a serial device at a specified baud rate with specified\nflags.  The device name must …\n"],["serial_read","Pigpio::IF","Pigpio/IF.html#method-c-serial_read","(p1, p2, p3)","<p>This function reads up to count bytes from the the serial port associated\nwith handle and writes them …\n"],["serial_read_byte","Pigpio::IF","Pigpio/IF.html#method-c-serial_read_byte","(p1, p2)","<p>This function reads a byte from the serial port associated with handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by ...</pre>\n"],["serial_write","Pigpio::IF","Pigpio/IF.html#method-c-serial_write","(p1, p2, p3)","<p>This function writes count bytes from buf to the the serial port associated\nwith handle.\n<p>. .\n\n<pre>    pi: &gt;=0 ...</pre>\n"],["serial_write_byte","Pigpio::IF","Pigpio/IF.html#method-c-serial_write_byte","(p1, p2, p3)","<p>This function writes bVal to the serial port associated with handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["servo_pulsewidth","Pigpio::PWM","Pigpio/PWM.html#method-i-servo_pulsewidth","()",""],["servo_pulsewidth=","Pigpio::PWM","Pigpio/PWM.html#method-i-servo_pulsewidth-3D","(pulsewidth)",""],["set","Pigpio::Bank","Pigpio/Bank.html#method-i-set","(bits)",""],["set_PWM_dutycycle","Pigpio::IF","Pigpio/IF.html#method-c-set_PWM_dutycycle","(p1, p2, p3)","<p>Start (non-zero dutycycle) or stop (0) PWM pulses on the GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["set_PWM_frequency","Pigpio::IF","Pigpio/IF.html#method-c-set_PWM_frequency","(p1, p2, p3)","<p>Set the frequency (in Hz) of the PWM to be used on the GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["set_PWM_range","Pigpio::IF","Pigpio/IF.html#method-c-set_PWM_range","(p1, p2, p3)","<p>Set the range of PWM values to be used on the GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["set_bank_1","Pigpio::IF","Pigpio/IF.html#method-c-set_bank_1","(p1, p2)","<p>Sets GPIO 0-31 if the corresponding bit in bits is set.\n<p>. .\n\n<pre>  pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["set_bank_2","Pigpio::IF","Pigpio/IF.html#method-c-set_bank_2","(p1, p2)","<p>Sets GPIO 32-53 if the corresponding bit (0-21) in bits is set.\n<p>. .\n\n<pre>  pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["set_glitch_filter","Pigpio::IF","Pigpio/IF.html#method-c-set_glitch_filter","(p1, p2, p3)","<p>Sets a glitch filter on a GPIO.\n<p>Level changes on the GPIO are not reported unless the level has been stable\n…\n"],["set_mode","Pigpio::IF","Pigpio/IF.html#method-c-set_mode","(p1, p2, p3)","<p>Set the GPIO mode.\n<p>. .\n\n<pre>  pi: &gt;=0 (as returned by [*pigpio_start*]).\ngpio: 0-53.\nmode: PI_INPUT, PI_OUTPUT, ...</pre>\n"],["set_noise_filter","Pigpio::IF","Pigpio/IF.html#method-c-set_noise_filter","(p1, p2, p3, p4)","<p>Sets a noise filter on a GPIO.\n<p>Level changes on the GPIO are ignored until a level which has been stable …\n"],["set_pad_strength","Pigpio::IF","Pigpio/IF.html#method-c-set_pad_strength","(p1, p2, p3)","<p>This function sets the pad drive strength in mA.\n<p>. .\n\n<pre>         pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["set_pull_up_down","Pigpio::IF","Pigpio/IF.html#method-c-set_pull_up_down","(p1, p2, p3)","<p>Set or clear the GPIO pull-up/down resistor.\n<p>. .\n\n<pre>  pi: &gt;=0 (as returned by [*pigpio_start*]).\ngpio: 0-53. ...</pre>\n"],["set_servo_pulsewidth","Pigpio::IF","Pigpio/IF.html#method-c-set_servo_pulsewidth","(p1, p2, p3)","<p>Start (500-2500) or stop (0) servo pulses on the GPIO.\n<p>. .\n\n<pre>        pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["set_watchdog","Pigpio::IF","Pigpio/IF.html#method-c-set_watchdog","(p1, p2, p3)","<p>Sets a watchdog for a GPIO.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]).\nuser_gpio: 0-31.\n  timeout: ...</pre>\n"],["spi_close","Pigpio::IF","Pigpio/IF.html#method-c-spi_close","(p1, p2)","<p>This functions closes the SPI device identified by the handle.\n<p>. .\n\n<pre>    pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["spi_open","Pigpio::IF","Pigpio/IF.html#method-c-spi_open","(p1, p2, p3, p4)","<p>This function returns a handle for the SPI device on channel. Data will be\ntransferred at baud bits per …\n"],["spi_read","Pigpio::IF","Pigpio/IF.html#method-c-spi_read","(p1, p2, p3)","<p>This function reads count bytes of data from the SPI device associated with\nthe handle.\n<p>. .\n\n<pre>    pi: &gt;=0 ...</pre>\n"],["spi_write","Pigpio::IF","Pigpio/IF.html#method-c-spi_write","(p1, p2, p3)","<p>This function writes count bytes of data from buf to the SPI device\nassociated with the handle.\n<p>. .\n\n<pre>   ...</pre>\n"],["spi_xfer","Pigpio::IF","Pigpio/IF.html#method-c-spi_xfer","(p1, p2, p3)","<p>This function transfers count bytes of data from txBuf to the SPI device\nassociated with the handle. …\n"],["stop","Pigpio","Pigpio.html#method-i-stop","()",""],["stop_script","Pigpio::IF","Pigpio/IF.html#method-c-stop_script","(p1, p2)","<p>This function stops a running script.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned by [*pigpio_start*]).\nscript_id: ...</pre>\n"],["store_script","Pigpio::IF","Pigpio/IF.html#method-c-store_script","(p1, p2)","<p>This function stores a script for later execution.\n<p>See [[abyz.co.uk/rpi/pigpio/pigs.html#Scripts]] for …\n"],["time_time","Pigpio::IF","Pigpio/IF.html#method-c-time_time","()","<p>Return the current time in seconds since the Epoch.\n<p>See also: pigpio site\n"],["trigger","Pigpio::UserGPIO","Pigpio/UserGPIO.html#method-i-trigger","(pulseLen,level)",""],["txBuf=","Pigpio::BscXfer","Pigpio/BscXfer.html#method-i-txBuf-3D","(p1)","<p>Setter\n"],["wait_for_edge","Pigpio::IF","Pigpio/IF.html#method-c-wait_for_edge","(p1, p2, p3, p4)","<p>This function waits for an edge on the GPIO for up to timeout seconds.\n<p>. .\n\n<pre>       pi: &gt;=0 (as returned ...</pre>\n"],["wait_for_edge","Pigpio::UserGPIO","Pigpio/UserGPIO.html#method-i-wait_for_edge","(edge,timeout)",""],["wait_for_event","Pigpio::IF","Pigpio/IF.html#method-c-wait_for_event","(p1, p2, p3)","<p>This function waits for an event for up to timeout seconds.\n<p>. .\n\n<pre>     pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["watchdog","Pigpio::UserGPIO","Pigpio/UserGPIO.html#method-i-watchdog","(timeout)",""],["wave_add_generic","Pigpio::IF","Pigpio/IF.html#method-c-wave_add_generic","(p1, p2)","<p>This function adds a number of pulses to the current waveform.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["wave_add_new","Pigpio::IF","Pigpio/IF.html#method-c-wave_add_new","(p1)","<p>This function starts a new empty waveform.  You wouldn&#39;t normally need\nto call this function as it …\n"],["wave_add_serial","Pigpio::IF","Pigpio/IF.html#method-c-wave_add_serial","(p1, p2, p3, p4, p5, p6, p7)","<p>This function adds a waveform representing serial data to the existing\nwaveform (if any).  The serial …\n"],["wave_chain","Pigpio::IF","Pigpio/IF.html#method-c-wave_chain","(p1, p2)","<p>This function transmits a chain of waveforms.\n<p>NOTE: Any hardware PWM started by [<strong>hardware_PWM</strong>] will be …\n"],["wave_clear","Pigpio::IF","Pigpio/IF.html#method-c-wave_clear","(p1)","<p>This function clears all waveforms and any data added by calls to the\n<p>wave_add_* &mdash; functions.\n\n<p>. .\n"],["wave_create","Pigpio::IF","Pigpio/IF.html#method-c-wave_create","(p1)","<p>This function creates a waveform from the data provided by the prior calls\nto the [<strong>wave_add_</strong>*] functions. …\n"],["wave_delete","Pigpio::IF","Pigpio/IF.html#method-c-wave_delete","(p1, p2)","<p>This function deletes the waveform with id wave_id.\n<p>. .\n\n<pre>     pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["wave_get_cbs","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_cbs","(p1)","<p>This function returns the length in DMA control blocks of the current\nwaveform.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned ...</pre>\n"],["wave_get_high_cbs","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_high_cbs","(p1)","<p>This function returns the length in DMA control blocks of the longest\nwaveform created since the pigpio …\n"],["wave_get_high_micros","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_high_micros","(p1)","<p>This function returns the length in microseconds of the longest waveform\ncreated since the pigpio daemon …\n"],["wave_get_high_pulses","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_high_pulses","(p1)","<p>This function returns the length in pulses of the longest waveform created\nsince the pigpio daemon was …\n"],["wave_get_max_cbs","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_max_cbs","(p1)","<p>This function returns the maximum possible size of a waveform in DMA\ncontrol blocks.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned ...</pre>\n"],["wave_get_max_micros","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_max_micros","(p1)","<p>This function returns the maximum possible size of a waveform in \nmicroseconds.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned ...</pre>\n"],["wave_get_max_pulses","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_max_pulses","(p1)","<p>This function returns the maximum possible size of a waveform in pulses.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["wave_get_micros","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_micros","(p1)","<p>This function returns the length in microseconds of the current waveform.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["wave_get_pulses","Pigpio::IF","Pigpio/IF.html#method-c-wave_get_pulses","(p1)","<p>This function returns the length in pulses of the current waveform.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["wave_send_once","Pigpio::IF","Pigpio/IF.html#method-c-wave_send_once","(p1, p2)","<p>This function transmits the waveform with id wave_id.  The waveform is sent\nonce.\n<p>NOTE: Any hardware  …\n"],["wave_send_repeat","Pigpio::IF","Pigpio/IF.html#method-c-wave_send_repeat","(p1, p2)","<p>This function transmits the waveform with id wave_id.  The waveform cycles\nuntil cancelled (either by …\n"],["wave_send_using_mode","Pigpio::IF","Pigpio/IF.html#method-c-wave_send_using_mode","(p1, p2, p3)","<p>Transmits the waveform with id wave_id using mode mode.\n<p>. .\n\n<pre>     pi: &gt;=0 (as returned by [*pigpio_start*]). ...</pre>\n"],["wave_tx_at","Pigpio::IF","Pigpio/IF.html#method-c-wave_tx_at","(p1)","<p>This function returns the id of the waveform currently being transmitted.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["wave_tx_busy","Pigpio::IF","Pigpio/IF.html#method-c-wave_tx_busy","(p1)","<p>This function checks to see if a waveform is currently being transmitted.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["wave_tx_stop","Pigpio::IF","Pigpio/IF.html#method-c-wave_tx_stop","(p1)","<p>This function stops the transmission of the current waveform.\n<p>. .\n\n<pre>pi: &gt;=0 (as returned by [*pigpio_start*]).</pre>\n"],["write","Pigpio::GPIO","Pigpio/GPIO.html#method-i-write","(level)",""]]}}